"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._extractEntryTo = _extractEntryTo;
exports.assertValidZip = assertValidZip;
exports.default = void 0;
exports.extractAllTo = extractAllTo;
exports.readEntries = readEntries;
exports.toArchive = toArchive;
exports.toInMemoryZip = toInMemoryZip;

require("source-map-support/register");

var _lodash = _interopRequireDefault(require("lodash"));

var _bluebird = _interopRequireDefault(require("bluebird"));

var _yauzl = _interopRequireDefault(require("yauzl"));

var _archiver = _interopRequireDefault(require("archiver"));

var _fs = require("fs");

var _path = _interopRequireDefault(require("path"));

var _stream = _interopRequireDefault(require("stream"));

var _fs2 = _interopRequireDefault(require("./fs"));

var _system = require("./system");

var _base64Stream = require("base64-stream");

var _util = require("./util");

var _timing = _interopRequireDefault(require("./timing"));

var _logger = _interopRequireDefault(require("./logger"));

var _getStream = _interopRequireDefault(require("get-stream"));

var _teen_process = require("teen_process");

const openZip = _bluebird.default.promisify(_yauzl.default.open);

const pipeline = _bluebird.default.promisify(_stream.default.pipeline);

const ZIP_MAGIC = 'PK';
const IFMT = 61440;
const IFDIR = 16384;
const IFLNK = 40960;

class ZipExtractor {
  zipfile;

  constructor(sourcePath, opts = {}) {
    this.zipPath = sourcePath;
    this.opts = opts;
    this.canceled = false;
  }

  extractFileName(entry) {
    return _lodash.default.isBuffer(entry.fileName) ? entry.fileName.toString(this.opts.fileNamesEncoding) : entry.fileName;
  }

  async extract() {
    const {
      dir,
      fileNamesEncoding
    } = this.opts;
    this.zipfile = await openZip(this.zipPath, {
      lazyEntries: true,
      decodeStrings: !fileNamesEncoding
    });
    this.canceled = false;
    return new _bluebird.default((resolve, reject) => {
      this.zipfile.on('error', err => {
        this.canceled = true;
        reject(err);
      });
      this.zipfile.readEntry();
      this.zipfile.on('close', () => {
        if (!this.canceled) {
          resolve();
        }
      });
      this.zipfile.on('entry', async entry => {
        if (this.canceled) {
          return;
        }

        const fileName = this.extractFileName(entry);

        if (fileName.startsWith('__MACOSX/')) {
          this.zipfile.readEntry();
          return;
        }

        const destDir = _path.default.dirname(_path.default.join(dir, fileName));

        try {
          await _fs2.default.mkdir(destDir, {
            recursive: true
          });
          const canonicalDestDir = await _fs2.default.realpath(destDir);

          const relativeDestDir = _path.default.relative(dir, canonicalDestDir);

          if (relativeDestDir.split(_path.default.sep).includes('..')) {
            new Error(`Out of bound path "${canonicalDestDir}" found while processing file ${fileName}`);
          }

          await this.extractEntry(entry);
          this.zipfile.readEntry();
        } catch (err) {
          this.canceled = true;
          this.zipfile.close();
          reject(err);
        }
      });
    });
  }

  async extractEntry(entry) {
    if (this.canceled) {
      return;
    }

    const {
      dir
    } = this.opts;
    const fileName = this.extractFileName(entry);

    const dest = _path.default.join(dir, fileName);

    const mode = entry.externalFileAttributes >> 16 & 0xFFFF;
    const isSymlink = (mode & IFMT) === IFLNK;
    const isDir = (mode & IFMT) === IFDIR || fileName.endsWith('/') || entry.versionMadeBy >> 8 === 0 && entry.externalFileAttributes === 16;
    const procMode = this.getExtractedMode(mode, isDir) & 0o777;
    const destDir = isDir ? dest : _path.default.dirname(dest);
    const mkdirOptions = {
      recursive: true
    };

    if (isDir) {
      mkdirOptions.mode = procMode;
    }

    await _fs2.default.mkdir(destDir, mkdirOptions);

    if (isDir) {
      return;
    }

    const openReadStream = _bluebird.default.promisify(this.zipfile.openReadStream.bind(this.zipfile));

    const readStream = await openReadStream(entry);

    if (isSymlink) {
      const link = await (0, _getStream.default)(readStream);
      await _fs2.default.symlink(link, dest);
    } else {
      await pipeline(readStream, _fs2.default.createWriteStream(dest, {
        mode: procMode
      }));
    }
  }

  getExtractedMode(entryMode, isDir) {
    const {
      defaultDirMode,
      defaultFileMode
    } = this.opts;
    let mode = entryMode;

    if (mode === 0) {
      if (isDir) {
        if (defaultDirMode) {
          mode = parseInt(defaultDirMode, 10);
        }

        if (!mode) {
          mode = 0o755;
        }
      } else {
        if (defaultFileMode) {
          mode = parseInt(defaultFileMode, 10);
        }

        if (!mode) {
          mode = 0o644;
        }
      }
    }

    return mode;
  }

}

async function extractAllTo(zipFilePath, destDir, opts = {}) {
  if (!_path.default.isAbsolute(destDir)) {
    throw new Error(`Target path '${destDir}' is expected to be absolute`);
  }

  await _fs2.default.mkdir(destDir, {
    recursive: true
  });
  const dir = await _fs2.default.realpath(destDir);

  if (opts.useSystemUnzip) {
    try {
      await extractWithSystemUnzip(zipFilePath, dir);
      return;
    } catch (err) {
      _logger.default.warn('unzip failed; falling back to JS: %s', err.stderr || err.message);
    }
  }

  const extractor = new ZipExtractor(zipFilePath, { ...opts,
    dir
  });
  await extractor.extract();
}

async function extractWithSystemUnzip(zipFilePath, destDir) {
  const isWindowsHost = (0, _system.isWindows)();
  let executablePath;

  try {
    executablePath = await getExecutablePath(isWindowsHost ? 'powershell.exe' : 'unzip');
  } catch (e) {
    throw new Error('Could not find system unzip');
  }

  if (isWindowsHost) {
    await (0, _teen_process.exec)(executablePath, ['-command', 'Expand-Archive', '-LiteralPath', zipFilePath, '-DestinationPath', destDir, '-Force']);
  } else {
    await (0, _teen_process.exec)(executablePath, ['-q', '-o', zipFilePath, '-d', destDir]);
  }
}

async function _extractEntryTo(zipFile, entry, destDir) {
  const dstPath = _path.default.resolve(destDir, entry.fileName);

  if (/\/$/.test(entry.fileName)) {
    if (!(await _fs2.default.exists(dstPath))) {
      await _fs2.default.mkdirp(dstPath);
    }

    return;
  } else if (!(await _fs2.default.exists(_path.default.dirname(dstPath)))) {
    await _fs2.default.mkdirp(_path.default.dirname(dstPath));
  }

  const writeStream = (0, _fs.createWriteStream)(dstPath, {
    flags: 'w'
  });
  const writeStreamPromise = new _bluebird.default((resolve, reject) => {
    writeStream.once('finish', resolve);
    writeStream.once('error', reject);
  });
  const zipReadStream = await new _bluebird.default((resolve, reject) => {
    zipFile.openReadStream(entry, (err, readStream) => err ? reject(err) : resolve(readStream));
  });
  const zipReadStreamPromise = new _bluebird.default((resolve, reject) => {
    zipReadStream.once('end', resolve);
    zipReadStream.once('error', reject);
  });
  zipReadStream.pipe(writeStream);
  return await _bluebird.default.all([zipReadStreamPromise, writeStreamPromise]);
}

async function readEntries(zipFilePath, onEntry) {
  const zipfile = await openZip(zipFilePath, {
    lazyEntries: true
  });
  const zipReadStreamPromise = new _bluebird.default((resolve, reject) => {
    zipfile.once('end', resolve);
    zipfile.once('error', reject);
    zipfile.on('entry', async entry => {
      const res = await onEntry({
        entry,
        extractEntryTo: async destDir => await _extractEntryTo(zipfile, entry, destDir)
      });

      if (res === false) {
        return zipfile.emit('end');
      }

      zipfile.readEntry();
    });
  });
  zipfile.readEntry();
  return await zipReadStreamPromise;
}

async function toInMemoryZip(srcPath, opts = {}) {
  if (!(await _fs2.default.exists(srcPath))) {
    throw new Error(`No such file or folder: ${srcPath}`);
  }

  const {
    isMetered = true,
    encodeToBase64 = false,
    maxSize = 1 * _util.GiB,
    level = 9
  } = opts;
  const resultBuffers = [];
  let resultBuffersSize = 0;
  const resultWriteStream = new _stream.default.Writable({
    write: (buffer, encoding, next) => {
      resultBuffers.push(buffer);
      resultBuffersSize += buffer.length;

      if (maxSize > 0 && resultBuffersSize > maxSize) {
        resultWriteStream.emit('error', new Error(`The size of the resulting ` + `archive must not be greater than ${(0, _util.toReadableSizeString)(maxSize)}`));
      }

      next();
    }
  });
  const archive = (0, _archiver.default)('zip', {
    zlib: {
      level
    }
  });
  let srcSize = null;
  const base64EncoderStream = encodeToBase64 ? new _base64Stream.Base64Encode() : null;
  const resultWriteStreamPromise = new _bluebird.default((resolve, reject) => {
    resultWriteStream.once('error', e => {
      if (base64EncoderStream) {
        archive.unpipe(base64EncoderStream);
        base64EncoderStream.unpipe(resultWriteStream);
      } else {
        archive.unpipe(resultWriteStream);
      }

      archive.abort();
      archive.destroy();
      reject(e);
    });
    resultWriteStream.once('finish', () => {
      srcSize = archive.pointer();
      resolve();
    });
  });
  const archiveStreamPromise = new _bluebird.default((resolve, reject) => {
    archive.once('finish', resolve);
    archive.once('error', e => reject(new Error(`Failed to archive '${srcPath}': ${e.message}`)));
  });
  const timer = isMetered ? new _timing.default().start() : null;

  if ((await _fs2.default.stat(srcPath)).isDirectory()) {
    archive.directory(srcPath, false);
  } else {
    archive.file(srcPath, {
      name: _path.default.basename(srcPath)
    });
  }

  if (base64EncoderStream) {
    archive.pipe(base64EncoderStream);
    base64EncoderStream.pipe(resultWriteStream);
  } else {
    archive.pipe(resultWriteStream);
  }

  archive.finalize();
  await _bluebird.default.all([archiveStreamPromise, resultWriteStreamPromise]);

  if (timer) {
    _logger.default.debug(`Zipped ${encodeToBase64 ? 'and base64-encoded ' : ''}` + `'${_path.default.basename(srcPath)}' ` + (srcSize ? `(${(0, _util.toReadableSizeString)(srcSize)}) ` : '') + `in ${timer.getDuration().asSeconds.toFixed(3)}s ` + `(compression level: ${level})`);
  }

  return Buffer.concat(resultBuffers);
}

async function assertValidZip(filePath) {
  if (!(await _fs2.default.exists(filePath))) {
    throw new Error(`The file at '${filePath}' does not exist`);
  }

  const {
    size
  } = await _fs2.default.stat(filePath);

  if (size < 4) {
    throw new Error(`The file at '${filePath}' is too small to be a ZIP archive`);
  }

  const fd = await _fs2.default.open(filePath, 'r');

  try {
    const buffer = Buffer.alloc(ZIP_MAGIC.length);
    await _fs2.default.read(fd, buffer, 0, ZIP_MAGIC.length, 0);
    const signature = buffer.toString('ascii');

    if (signature !== ZIP_MAGIC) {
      throw new Error(`The file signature '${signature}' of '${filePath}' ` + `is not equal to the expected ZIP archive signature '${ZIP_MAGIC}'`);
    }

    return true;
  } finally {
    await _fs2.default.close(fd);
  }
}

async function toArchive(dstPath, src = {}, opts = {}) {
  const {
    level = 9
  } = opts;
  const {
    pattern = '**/*',
    cwd = _path.default.dirname(dstPath),
    ignore = []
  } = src;
  const archive = (0, _archiver.default)('zip', {
    zlib: {
      level
    }
  });

  const stream = _fs2.default.createWriteStream(dstPath);

  return await new _bluebird.default((resolve, reject) => {
    archive.glob(pattern, {
      cwd,
      ignore
    }).on('error', reject).pipe(stream);
    stream.on('error', e => {
      archive.unpipe(stream);
      archive.abort();
      archive.destroy();
      reject(e);
    }).on('finish', resolve);
    archive.finalize();
  });
}

const getExecutablePath = _lodash.default.memoize(async function getExecutablePath(binaryName) {
  const fullPath = await _fs2.default.which(binaryName);

  _logger.default.debug(`Found '%s' at '%s'`, binaryName, fullPath);

  return fullPath;
});

var _default = {
  extractAllTo,
  readEntries,
  toInMemoryZip,
  assertValidZip,
  toArchive
};
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi96aXAuanMiXSwibmFtZXMiOlsib3BlblppcCIsIkIiLCJwcm9taXNpZnkiLCJ5YXV6bCIsIm9wZW4iLCJwaXBlbGluZSIsInN0cmVhbSIsIlpJUF9NQUdJQyIsIklGTVQiLCJJRkRJUiIsIklGTE5LIiwiWmlwRXh0cmFjdG9yIiwiemlwZmlsZSIsImNvbnN0cnVjdG9yIiwic291cmNlUGF0aCIsIm9wdHMiLCJ6aXBQYXRoIiwiY2FuY2VsZWQiLCJleHRyYWN0RmlsZU5hbWUiLCJlbnRyeSIsIl8iLCJpc0J1ZmZlciIsImZpbGVOYW1lIiwidG9TdHJpbmciLCJmaWxlTmFtZXNFbmNvZGluZyIsImV4dHJhY3QiLCJkaXIiLCJsYXp5RW50cmllcyIsImRlY29kZVN0cmluZ3MiLCJyZXNvbHZlIiwicmVqZWN0Iiwib24iLCJlcnIiLCJyZWFkRW50cnkiLCJzdGFydHNXaXRoIiwiZGVzdERpciIsInBhdGgiLCJkaXJuYW1lIiwiam9pbiIsImZzIiwibWtkaXIiLCJyZWN1cnNpdmUiLCJjYW5vbmljYWxEZXN0RGlyIiwicmVhbHBhdGgiLCJyZWxhdGl2ZURlc3REaXIiLCJyZWxhdGl2ZSIsInNwbGl0Iiwic2VwIiwiaW5jbHVkZXMiLCJFcnJvciIsImV4dHJhY3RFbnRyeSIsImNsb3NlIiwiZGVzdCIsIm1vZGUiLCJleHRlcm5hbEZpbGVBdHRyaWJ1dGVzIiwiaXNTeW1saW5rIiwiaXNEaXIiLCJlbmRzV2l0aCIsInZlcnNpb25NYWRlQnkiLCJwcm9jTW9kZSIsImdldEV4dHJhY3RlZE1vZGUiLCJta2Rpck9wdGlvbnMiLCJvcGVuUmVhZFN0cmVhbSIsImJpbmQiLCJyZWFkU3RyZWFtIiwibGluayIsInN5bWxpbmsiLCJjcmVhdGVXcml0ZVN0cmVhbSIsImVudHJ5TW9kZSIsImRlZmF1bHREaXJNb2RlIiwiZGVmYXVsdEZpbGVNb2RlIiwicGFyc2VJbnQiLCJleHRyYWN0QWxsVG8iLCJ6aXBGaWxlUGF0aCIsImlzQWJzb2x1dGUiLCJ1c2VTeXN0ZW1VbnppcCIsImV4dHJhY3RXaXRoU3lzdGVtVW56aXAiLCJsb2ciLCJ3YXJuIiwic3RkZXJyIiwibWVzc2FnZSIsImV4dHJhY3RvciIsImlzV2luZG93c0hvc3QiLCJleGVjdXRhYmxlUGF0aCIsImdldEV4ZWN1dGFibGVQYXRoIiwiZSIsIl9leHRyYWN0RW50cnlUbyIsInppcEZpbGUiLCJkc3RQYXRoIiwidGVzdCIsImV4aXN0cyIsIm1rZGlycCIsIndyaXRlU3RyZWFtIiwiZmxhZ3MiLCJ3cml0ZVN0cmVhbVByb21pc2UiLCJvbmNlIiwiemlwUmVhZFN0cmVhbSIsInppcFJlYWRTdHJlYW1Qcm9taXNlIiwicGlwZSIsImFsbCIsInJlYWRFbnRyaWVzIiwib25FbnRyeSIsInJlcyIsImV4dHJhY3RFbnRyeVRvIiwiZW1pdCIsInRvSW5NZW1vcnlaaXAiLCJzcmNQYXRoIiwiaXNNZXRlcmVkIiwiZW5jb2RlVG9CYXNlNjQiLCJtYXhTaXplIiwiR2lCIiwibGV2ZWwiLCJyZXN1bHRCdWZmZXJzIiwicmVzdWx0QnVmZmVyc1NpemUiLCJyZXN1bHRXcml0ZVN0cmVhbSIsIldyaXRhYmxlIiwid3JpdGUiLCJidWZmZXIiLCJlbmNvZGluZyIsIm5leHQiLCJwdXNoIiwibGVuZ3RoIiwiYXJjaGl2ZSIsInpsaWIiLCJzcmNTaXplIiwiYmFzZTY0RW5jb2RlclN0cmVhbSIsIkJhc2U2NEVuY29kZSIsInJlc3VsdFdyaXRlU3RyZWFtUHJvbWlzZSIsInVucGlwZSIsImFib3J0IiwiZGVzdHJveSIsInBvaW50ZXIiLCJhcmNoaXZlU3RyZWFtUHJvbWlzZSIsInRpbWVyIiwiVGltZXIiLCJzdGFydCIsInN0YXQiLCJpc0RpcmVjdG9yeSIsImRpcmVjdG9yeSIsImZpbGUiLCJuYW1lIiwiYmFzZW5hbWUiLCJmaW5hbGl6ZSIsImRlYnVnIiwiZ2V0RHVyYXRpb24iLCJhc1NlY29uZHMiLCJ0b0ZpeGVkIiwiQnVmZmVyIiwiY29uY2F0IiwiYXNzZXJ0VmFsaWRaaXAiLCJmaWxlUGF0aCIsInNpemUiLCJmZCIsImFsbG9jIiwicmVhZCIsInNpZ25hdHVyZSIsInRvQXJjaGl2ZSIsInNyYyIsInBhdHRlcm4iLCJjd2QiLCJpZ25vcmUiLCJnbG9iIiwibWVtb2l6ZSIsImJpbmFyeU5hbWUiLCJmdWxsUGF0aCIsIndoaWNoIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUtBLE1BQU1BLE9BQU8sR0FBR0Msa0JBQUVDLFNBQUYsQ0FBWUMsZUFBTUMsSUFBbEIsQ0FBaEI7O0FBSUEsTUFBTUMsUUFBUSxHQUFHSixrQkFBRUMsU0FBRixDQUFZSSxnQkFBT0QsUUFBbkIsQ0FBakI7O0FBQ0EsTUFBTUUsU0FBUyxHQUFHLElBQWxCO0FBQ0EsTUFBTUMsSUFBSSxHQUFHLEtBQWI7QUFDQSxNQUFNQyxLQUFLLEdBQUcsS0FBZDtBQUNBLE1BQU1DLEtBQUssR0FBRyxLQUFkOztBQUdBLE1BQU1DLFlBQU4sQ0FBbUI7QUFFakJDLEVBQUFBLE9BQU87O0FBRVBDLEVBQUFBLFdBQVcsQ0FBRUMsVUFBRixFQUFjQyxJQUFJLEdBQUcsRUFBckIsRUFBeUI7QUFDbEMsU0FBS0MsT0FBTCxHQUFlRixVQUFmO0FBQ0EsU0FBS0MsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsU0FBS0UsUUFBTCxHQUFnQixLQUFoQjtBQUNEOztBQUVEQyxFQUFBQSxlQUFlLENBQUVDLEtBQUYsRUFBUztBQUN0QixXQUFPQyxnQkFBRUMsUUFBRixDQUFXRixLQUFLLENBQUNHLFFBQWpCLElBQTZCSCxLQUFLLENBQUNHLFFBQU4sQ0FBZUMsUUFBZixDQUF3QixLQUFLUixJQUFMLENBQVVTLGlCQUFsQyxDQUE3QixHQUFvRkwsS0FBSyxDQUFDRyxRQUFqRztBQUNEOztBQUVZLFFBQVBHLE9BQU8sR0FBSTtBQUNmLFVBQU07QUFDSkMsTUFBQUEsR0FESTtBQUVKRixNQUFBQTtBQUZJLFFBR0YsS0FB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QU5ILENBTVE1RixNQU5SO0FBT0FBLElBQUFBLE1BQU0sQ0FDSHlCLEVBREgsQ0FDTSxPQUROLEVBQ2dCc0QsQ0FBRCxJQUFPO0FBQ2xCcUMsTUFBQUEsT0FBTyxDQUFDTSxNQUFSLENBQWUxSCxNQUFmO0FBQ0FvSCxNQUFBQSxPQUFPLENBQUNPLEtBQVI7QUFDQVAsTUFBQUEsT0FBTyxDQUFDUSxPQUFSO0FBQ0FwRyxNQUFBQSxNQUFNLENBQUN1RCxDQUFELENBQU47QUFDRCxLQU5ILEVBT0d0RCxFQVBILENBT00sUUFQTixFQU9nQkYsT0FQaEI7QUFRQTZGLElBQUFBLE9BQU8sQ0FBQ29CLFFBQVI7QUFDRCxHQWpCWSxDQUFiO0FBa0JEOztBQU1ELE1BQU0xRCxpQkFBaUIsR0FBR2hFLGdCQUFFOEksT0FBRixDQUl4QixlQUFlOUUsaUJBQWYsQ0FBa0MrRSxVQUFsQyxFQUE4QztBQUM1QyxRQUFNQyxRQUFRLEdBQUcsTUFBTTdILGFBQUc4SCxLQUFILENBQVNGLFVBQVQsQ0FBdkI7O0FBQ0F0RixrQkFBSWtFLEtBQUosQ0FBVyxvQkFBWCxFQUFnQ29CLFVBQWhDLEVBQTRDQyxRQUE1Qzs7QUFDQSxTQUFPQSxRQUFQO0FBQ0QsQ0FSdUIsQ0FBMUI7O2VBYWU7QUFBRTVGLEVBQUFBLFlBQUY7QUFBZ0I0QixFQUFBQSxXQUFoQjtBQUE2QkssRUFBQUEsYUFBN0I7QUFBNEM0QyxFQUFBQSxjQUE1QztBQUE0RE8sRUFBQUE7QUFBNUQsQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgQiBmcm9tICdibHVlYmlyZCc7XG5pbXBvcnQgeWF1emwgZnJvbSAneWF1emwnO1xuaW1wb3J0IGFyY2hpdmVyIGZyb20gJ2FyY2hpdmVyJztcbmltcG9ydCB7IGNyZWF0ZVdyaXRlU3RyZWFtIH0gZnJvbSAnZnMnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgc3RyZWFtIGZyb20gJ3N0cmVhbSc7XG5pbXBvcnQgZnMgZnJvbSAnLi9mcyc7XG5pbXBvcnQgeyBpc1dpbmRvd3MgfSBmcm9tICcuL3N5c3RlbSc7XG5pbXBvcnQgeyBCYXNlNjRFbmNvZGUgfSBmcm9tICdiYXNlNjQtc3RyZWFtJztcbmltcG9ydCB7IHRvUmVhZGFibGVTaXplU3RyaW5nLCBHaUIgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IFRpbWVyIGZyb20gJy4vdGltaW5nJztcbmltcG9ydCBsb2cgZnJvbSAnLi9sb2dnZXInO1xuaW1wb3J0IGdldFN0cmVhbSBmcm9tICdnZXQtc3RyZWFtJztcbmltcG9ydCB7IGV4ZWMgfSBmcm9tICd0ZWVuX3Byb2Nlc3MnO1xuXG4vKipcbiAqIEB0eXBlIHsocGF0aDogc3RyaW5nLCBvcHRpb25zPzogeWF1emwuT3B0aW9ucykgPT4gUHJvbWlzZTx5YXV6bC5aaXBGaWxlPn1cbiAqL1xuY29uc3Qgb3BlblppcCA9IEIucHJvbWlzaWZ5KHlhdXpsLm9wZW4pO1xuLyoqXG4gKiBAdHlwZSB7KHNvdXJjZTogTm9kZUpTLlJlYWRhYmxlU3RyZWFtLCBkZXN0aW5hdGlvbjogTm9kZUpTLldyaXRhYmxlU3RyZWFtKSA9PiBQcm9taXNlPE5vZGVKUy5Xcml0YWJsZVN0cmVhbT59XG4gKi9cbmNvbnN0IHBpcGVsaW5lID0gQi5wcm9taXNpZnkoc3RyZWFtLnBpcGVsaW5lKTtcbmNvbnN0IFpJUF9NQUdJQyA9ICdQSyc7XG5jb25zdCBJRk1UID0gNjE0NDA7XG5jb25zdCBJRkRJUiA9IDE2Mzg0O1xuY29uc3QgSUZMTksgPSA0MDk2MDtcblxuLy8gVGhpcyBjbGFzcyBpcyBtb3N0bHkgY29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21heG9nZGVuL2V4dHJhY3QtemlwL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG5jbGFzcyBaaXBFeHRyYWN0b3Ige1xuICAvKiogQHR5cGUge3lhdXpsLlppcEZpbGV9ICovXG4gIHppcGZpbGU7XG5cbiAgY29uc3RydWN0b3IgKHNvdXJjZVBhdGgsIG9wdHMgPSB7fSkge1xuICAgIHRoaXMuemlwUGF0aCA9IHNvdXJjZVBhdGg7XG4gICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICB0aGlzLmNhbmNlbGVkID0gZmFsc2U7XG4gIH1cblxuICBleHRyYWN0RmlsZU5hbWUgKGVudHJ5KSB7XG4gICAgcmV0dXJuIF8uaXNCdWZmZXIoZW50cnkuZmlsZU5hbWUpID8gZW50cnkuZmlsZU5hbWUudG9TdHJpbmcodGhpcy5vcHRzLmZpbGVOYW1lc0VuY29kaW5nKSA6IGVudHJ5LmZpbGVOYW1lO1xuICB9XG5cbiAgYXN5bmMgZXh0cmFjdCAoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGlyLFxuICAgICAgZmlsZU5hbWVzRW5jb2RpbmcsXG4gICAgfSA9IHRoaXMub3B0cztcbiAgICB0aGlzLnppcGZpbGUgPSBhd2FpdCBvcGVuWmlwKHRoaXMuemlwUGF0aCwge1xuICAgICAgbGF6eUVudHJpZXM6IHRydWUsXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdGhlam9zaHdvbGZlL3lhdXpsL2NvbW1pdC9jYzc0NTVhYzc4OWJhODQ5NzMxODRlNWViZGUwNTgxY2RjNGMzYjM5I2RpZmYtMDRjNmU5MGZhYWMyNjc1YWE4OWUyMTc2ZDJlZWM3ZDhSOTVcbiAgICAgIGRlY29kZVN0cmluZ3M6ICFmaWxlTmFtZXNFbmNvZGluZyxcbiAgICB9KTtcbiAgICB0aGlzLmNhbmNlbGVkID0gZmFsc2U7XG5cbiAgICByZXR1cm4gbmV3IEIoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy56aXBmaWxlLm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgICAgdGhpcy5jYW5jZWxlZCA9IHRydWU7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnppcGZpbGUucmVhZEVudHJ5KCk7XG5cbiAgICAgIHRoaXMuemlwZmlsZS5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5jYW5jZWxlZCkge1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuemlwZmlsZS5vbignZW50cnknLCBhc3luYyAoZW50cnkpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuY2FuY2VsZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBmaWxlTmFtZSA9IHRoaXMuZXh0cmFjdEZpbGVOYW1lKGVudHJ5KTtcbiAgICAgICAgaWYgKGZpbGVOYW1lLnN0YXJ0c1dpdGgoJ19fTUFDT1NYLycpKSB7XG4gICAgICAgICAgdGhpcy56aXBmaWxlLnJlYWRFbnRyeSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRlc3REaXIgPSBwYXRoLmRpcm5hbWUocGF0aC5qb2luKGRpciwgZmlsZU5hbWUpKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCBmcy5ta2RpcihkZXN0RGlyLCB7cmVjdXJzaXZlOiB0cnVlfSk7XG5cbiAgICAgICAgICBjb25zdCBjYW5vbmljYWxEZXN0RGlyID0gYXdhaXQgZnMucmVhbHBhdGgoZGVzdERpcik7XG4gICAgICAgICAgY29uc3QgcmVsYXRpdmVEZXN0RGlyID0gcGF0aC5yZWxhdGl2ZShkaXIsIGNhbm9uaWNhbERlc3REaXIpO1xuXG4gICAgICAgICAgaWYgKHJlbGF0aXZlRGVzdERpci5zcGxpdChwYXRoLnNlcCkuaW5jbHVkZXMoJy4uJykpIHtcbiAgICAgICAgICAgIG5ldyBFcnJvcihgT3V0IG9mIGJvdW5kIHBhdGggXCIke2Nhbm9uaWNhbERlc3REaXJ9XCIgZm91bmQgd2hpbGUgcHJvY2Vzc2luZyBmaWxlICR7ZmlsZU5hbWV9YCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXdhaXQgdGhpcy5leHRyYWN0RW50cnkoZW50cnkpO1xuICAgICAgICAgIHRoaXMuemlwZmlsZS5yZWFkRW50cnkoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhpcy5jYW5jZWxlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy56aXBmaWxlLmNsb3NlKCk7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgZXh0cmFjdEVudHJ5IChlbnRyeSkge1xuICAgIGlmICh0aGlzLmNhbmNlbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgZGlyLFxuICAgIH0gPSB0aGlzLm9wdHM7XG5cbiAgICBjb25zdCBmaWxlTmFtZSA9IHRoaXMuZXh0cmFjdEZpbGVOYW1lKGVudHJ5KTtcbiAgICBjb25zdCBkZXN0ID0gcGF0aC5qb2luKGRpciwgZmlsZU5hbWUpO1xuXG4gICAgLy8gY29udmVydCBleHRlcm5hbCBmaWxlIGF0dHIgaW50IGludG8gYSBmcyBzdGF0IG1vZGUgaW50XG4gICAgY29uc3QgbW9kZSA9IChlbnRyeS5leHRlcm5hbEZpbGVBdHRyaWJ1dGVzID4+IDE2KSAmIDB4RkZGRjtcbiAgICAvLyBjaGVjayBpZiBpdCdzIGEgc3ltbGluayBvciBkaXIgKHVzaW5nIHN0YXQgbW9kZSBjb25zdGFudHMpXG4gICAgY29uc3QgaXNTeW1saW5rID0gKG1vZGUgJiBJRk1UKSA9PT0gSUZMTks7XG4gICAgY29uc3QgaXNEaXIgPSAobW9kZSAmIElGTVQpID09PSBJRkRJUlxuICAgICAgLy8gRmFpbHNhZmUsIGJvcnJvd2VkIGZyb20ganNaaXBcbiAgICAgIHx8IGZpbGVOYW1lLmVuZHNXaXRoKCcvJylcbiAgICAgIC8vIGNoZWNrIGZvciB3aW5kb3dzIHdlaXJkIHdheSBvZiBzcGVjaWZ5aW5nIGEgZGlyZWN0b3J5XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWF4b2dkZW4vZXh0cmFjdC16aXAvaXNzdWVzLzEzI2lzc3VlY29tbWVudC0xNTQ0OTQ1NjZcbiAgICAgIHx8IChlbnRyeS52ZXJzaW9uTWFkZUJ5ID4+IDggPT09IDAgJiYgZW50cnkuZXh0ZXJuYWxGaWxlQXR0cmlidXRlcyA9PT0gMTYpO1xuICAgIGNvbnN0IHByb2NNb2RlID0gdGhpcy5nZXRFeHRyYWN0ZWRNb2RlKG1vZGUsIGlzRGlyKSAmIDBvNzc3O1xuICAgIC8vIGFsd2F5cyBlbnN1cmUgZm9sZGVycyBhcmUgY3JlYXRlZFxuICAgIGNvbnN0IGRlc3REaXIgPSBpc0RpciA/IGRlc3QgOiBwYXRoLmRpcm5hbWUoZGVzdCk7XG4gICAgY29uc3QgbWtkaXJPcHRpb25zID0geyByZWN1cnNpdmU6IHRydWUgfTtcbiAgICBpZiAoaXNEaXIpIHtcbiAgICAgIG1rZGlyT3B0aW9ucy5tb2RlID0gcHJvY01vZGU7XG4gICAgfVxuICAgIGF3YWl0IGZzLm1rZGlyKGRlc3REaXIsIG1rZGlyT3B0aW9ucyk7XG4gICAgaWYgKGlzRGlyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyoqIEB0eXBlIHsoZW50cnk6IHlhdXpsLkVudHJ5KSA9PiBQcm9taXNlPE5vZGVKUy5SZWFkYWJsZVN0cmVhbT59ICovXG4gICAgY29uc3Qgb3BlblJlYWRTdHJlYW0gPSBCLnByb21pc2lmeSh0aGlzLnppcGZpbGUub3BlblJlYWRTdHJlYW0uYmluZCh0aGlzLnppcGZpbGUpKTtcbiAgICBjb25zdCByZWFkU3RyZWFtID0gYXdhaXQgb3BlblJlYWRTdHJlYW0oZW50cnkpO1xuICAgIGlmIChpc1N5bWxpbmspIHtcbiAgICAgIGNvbnN0IGxpbmsgPSBhd2FpdCBnZXRTdHJlYW0ocmVhZFN0cmVhbSk7XG4gICAgICBhd2FpdCBmcy5zeW1saW5rKGxpbmssIGRlc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhd2FpdCBwaXBlbGluZShyZWFkU3RyZWFtLCBmcy5jcmVhdGVXcml0ZVN0cmVhbShkZXN0LCB7IG1vZGU6IHByb2NNb2RlIH0pKTtcbiAgICB9XG4gIH1cblxuICBnZXRFeHRyYWN0ZWRNb2RlIChlbnRyeU1vZGUsIGlzRGlyKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGVmYXVsdERpck1vZGUsXG4gICAgICBkZWZhdWx0RmlsZU1vZGUsXG4gICAgfSA9IHRoaXMub3B0cztcblxuICAgIGxldCBtb2RlID0gZW50cnlNb2RlO1xuICAgIC8vIFNldCBkZWZhdWx0cywgaWYgbmVjZXNzYXJ5XG4gICAgaWYgKG1vZGUgPT09IDApIHtcbiAgICAgIGlmIChpc0Rpcikge1xuICAgICAgICBpZiAoZGVmYXVsdERpck1vZGUpIHtcbiAgICAgICAgICBtb2RlID0gcGFyc2VJbnQoZGVmYXVsdERpck1vZGUsIDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbW9kZSkge1xuICAgICAgICAgIG1vZGUgPSAwbzc1NTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGRlZmF1bHRGaWxlTW9kZSkge1xuICAgICAgICAgIG1vZGUgPSBwYXJzZUludChkZWZhdWx0RmlsZU1vZGUsIDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbW9kZSkge1xuICAgICAgICAgIG1vZGUgPSAwbzY0NDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtb2RlO1xuICB9XG59XG5cblxuLyoqXG4gKiBAdHlwZWRlZiBFeHRyYWN0QWxsT3B0aW9uc1xuICogQHByb3BlcnR5IHs/c3RyaW5nfSBmaWxlTmFtZXNFbmNvZGluZyBUaGUgZW5jb2RpbmcgdG8gdXNlIGZvciBleHRyYWN0ZWQgZmlsZSBuYW1lcy5cbiAqIEZvciBaSVAgYXJjaGl2ZXMgY3JlYXRlZCBvbiBNYWNPUyBpdCBpcyB1c3VhbGx5IGV4cGVjdGVkIHRvIGJlIGB1dGY4YC5cbiAqIEJ5IGRlZmF1bHQgaXQgaXMgYXV0b2RldGVjdGVkIGJhc2VkIG9uIHRoZSBlbnRyeSBtZXRhZGF0YSBhbmQgaXMgb25seSBuZWVkZWQgdG8gYmUgc2V0IGV4cGxpY2l0bHlcbiAqIGlmIHRoZSBwYXJ0aWN1bGFyIGFyY2hpdmUgZG9lcyBub3QgY29tcGx5IHRvIHRoZSBzdGFuZGFyZHMsIHdoaWNoIGxlYWRzIHRvIGNvcnJ1cHRlZCBmaWxlIG5hbWVzXG4gKiBhZnRlciBleHRyYWN0aW9uLiBPbmx5IGFwcGxpY2FibGUgaWYgc3lzdGVtIHVuemlwIGJpbmFyeSBpcyBOT1QgYmVpbmcgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7P2Jvb2xlYW59IHVzZVN5c3RlbVVuemlwIFtmYWxzZV0gSWYgdHJ1ZSwgYXR0ZW1wdCB0byB1c2Ugc3lzdGVtIHVuemlwOyBpZiB0aGlzIGZhaWxzLFxuICogZmFsbGJhY2sgdG8gdGhlIEpTIHVuemlwIGltcGxlbWVudGF0aW9uLlxuICovXG5cbi8qKlxuICogRXh0cmFjdCB6aXBmaWxlIHRvIGEgZGlyZWN0b3J5XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHppcEZpbGVQYXRoIFRoZSBmdWxsIHBhdGggdG8gdGhlIHNvdXJjZSBaSVAgZmlsZVxuICogQHBhcmFtIHtzdHJpbmd9IGRlc3REaXIgVGhlIGZ1bGwgcGF0aCB0byB0aGUgZGVzdGluYXRpb24gZm9sZGVyXG4gKiBAcGFyYW0ge0V4dHJhY3RBbGxPcHRpb25zfSBbb3B0c11cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZXh0cmFjdEFsbFRvICh6aXBGaWxlUGF0aCwgZGVzdERpciwgb3B0cyA9IC8qKiBAdHlwZSB7RXh0cmFjdEFsbE9wdGlvbnN9ICovKHt9KSkge1xuICBpZiAoIXBhdGguaXNBYnNvbHV0ZShkZXN0RGlyKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGFyZ2V0IHBhdGggJyR7ZGVzdERpcn0nIGlzIGV4cGVjdGVkIHRvIGJlIGFic29sdXRlYCk7XG4gIH1cblxuICBhd2FpdCBmcy5ta2RpcihkZXN0RGlyLCB7cmVjdXJzaXZlOiB0cnVlfSk7XG4gIGNvbnN0IGRpciA9IGF3YWl0IGZzLnJlYWxwYXRoKGRlc3REaXIpO1xuICBpZiAob3B0cy51c2VTeXN0ZW1VbnppcCkge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBleHRyYWN0V2l0aFN5c3RlbVVuemlwKHppcEZpbGVQYXRoLCBkaXIpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nLndhcm4oJ3VuemlwIGZhaWxlZDsgZmFsbGluZyBiYWNrIHRvIEpTOiAlcycsIGVyci5zdGRlcnIgfHwgZXJyLm1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuICBjb25zdCBleHRyYWN0b3IgPSBuZXcgWmlwRXh0cmFjdG9yKHppcEZpbGVQYXRoLCB7XG4gICAgLi4ub3B0cyxcbiAgICBkaXIsXG4gIH0pO1xuICBhd2FpdCBleHRyYWN0b3IuZXh0cmFjdCgpO1xufVxuXG4vKipcbiAqIEV4ZWN1dGVzIHN5c3RlbSB1bnppcCAoZS5nLiwgYC91c3IvYmluL3VuemlwYCkuIElmIGF2YWlsYWJsZSwgaXQgaXNcbiAqIHNpZ25pZmljYW50bHkgZmFzdGVyIHRoYW4gdGhlIEpTIGltcGxlbWVudGF0aW9uLlxuICogQnkgZGVmYXVsdCBhbGwgZmlsZXMgaW4gdGhlIGRlc3REaXIgZ2V0IG92ZXJyaWRkZW4gaWYgYWxyZWFkeSBleGlzdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gemlwRmlsZVBhdGggVGhlIGZ1bGwgcGF0aCB0byB0aGUgc291cmNlIFpJUCBmaWxlXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVzdERpciBUaGUgZnVsbCBwYXRoIHRvIHRoZSBkZXN0aW5hdGlvbiBmb2xkZXIuXG4gKiBUaGlzIGZvbGRlciBpcyBleHBlY3RlZCB0byBhbHJlYWR5IGV4aXN0IGJlZm9yZSBleHRyYWN0aW5nIHRoZSBhcmNoaXZlLlxuICovXG5hc3luYyBmdW5jdGlvbiBleHRyYWN0V2l0aFN5c3RlbVVuemlwICh6aXBGaWxlUGF0aCwgZGVzdERpcikge1xuICBjb25zdCBpc1dpbmRvd3NIb3N0ID0gaXNXaW5kb3dzKCk7XG4gIGxldCBleGVjdXRhYmxlUGF0aDtcbiAgdHJ5IHtcbiAgICBleGVjdXRhYmxlUGF0aCA9IGF3YWl0IGdldEV4ZWN1dGFibGVQYXRoKFxuICAgICAgaXNXaW5kb3dzSG9zdCA/ICdwb3dlcnNoZWxsLmV4ZScgOiAndW56aXAnXG4gICAgKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgc3lzdGVtIHVuemlwJyk7XG4gIH1cblxuICBpZiAoaXNXaW5kb3dzSG9zdCkge1xuICAgIC8vIG9uIFdpbmRvd3Mgd2UgdXNlIFBvd2VyU2hlbGwgdG8gdW56aXAgZmlsZXNcbiAgICBhd2FpdCBleGVjKGV4ZWN1dGFibGVQYXRoLCBbXG4gICAgICAnLWNvbW1hbmQnLCAnRXhwYW5kLUFyY2hpdmUnLFxuICAgICAgJy1MaXRlcmFsUGF0aCcsIHppcEZpbGVQYXRoLFxuICAgICAgJy1EZXN0aW5hdGlvblBhdGgnLCBkZXN0RGlyLFxuICAgICAgJy1Gb3JjZSdcbiAgICBdKTtcbiAgfSBlbHNlIHtcbiAgICAvLyAtcSBtZWFucyBxdWlldCAobm8gc3Rkb3V0KVxuICAgIC8vIC1vIG1lYW5zIG92ZXJ3cml0ZVxuICAgIC8vIC1kIGlzIHRoZSBkZXN0IGRpclxuICAgIGF3YWl0IGV4ZWMoZXhlY3V0YWJsZVBhdGgsIFtcbiAgICAgICctcScsXG4gICAgICAnLW8nLCB6aXBGaWxlUGF0aCxcbiAgICAgICctZCcsIGRlc3REaXJcbiAgICBdKTtcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3QgYSBzaW5nbGUgemlwIGVudHJ5IHRvIGEgZGlyZWN0b3J5XG4gKlxuICogQHBhcmFtIHt5YXV6bC5aaXBGaWxlfSB6aXBGaWxlIFRoZSBzb3VyY2UgWklQIHN0cmVhbVxuICogQHBhcmFtIHt5YXV6bC5FbnRyeX0gZW50cnkgVGhlIGVudHJ5IGluc3RhbmNlXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVzdERpciBUaGUgZnVsbCBwYXRoIHRvIHRoZSBkZXN0aW5hdGlvbiBmb2xkZXJcbiAqL1xuYXN5bmMgZnVuY3Rpb24gX2V4dHJhY3RFbnRyeVRvICh6aXBGaWxlLCBlbnRyeSwgZGVzdERpcikge1xuICBjb25zdCBkc3RQYXRoID0gcGF0aC5yZXNvbHZlKGRlc3REaXIsIGVudHJ5LmZpbGVOYW1lKTtcblxuICAvLyBDcmVhdGUgZGVzdCBkaXJlY3RvcnkgaWYgZG9lc24ndCBleGlzdCBhbHJlYWR5XG4gIGlmICgvXFwvJC8udGVzdChlbnRyeS5maWxlTmFtZSkpIHtcbiAgICBpZiAoIWF3YWl0IGZzLmV4aXN0cyhkc3RQYXRoKSkge1xuICAgICAgYXdhaXQgZnMubWtkaXJwKGRzdFBhdGgpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoIWF3YWl0IGZzLmV4aXN0cyhwYXRoLmRpcm5hbWUoZHN0UGF0aCkpKSB7XG4gICAgYXdhaXQgZnMubWtkaXJwKHBhdGguZGlybmFtZShkc3RQYXRoKSk7XG4gIH1cblxuICAvLyBDcmVhdGUgYSB3cml0ZSBzdHJlYW1cbiAgY29uc3Qgd3JpdGVTdHJlYW0gPSBjcmVhdGVXcml0ZVN0cmVhbShkc3RQYXRoLCB7ZmxhZ3M6ICd3J30pO1xuICBjb25zdCB3cml0ZVN0cmVhbVByb21pc2UgPSBuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgd3JpdGVTdHJlYW0ub25jZSgnZmluaXNoJywgcmVzb2x2ZSk7XG4gICAgd3JpdGVTdHJlYW0ub25jZSgnZXJyb3InLCByZWplY3QpO1xuICB9KTtcblxuICAvLyBDcmVhdGUgemlwUmVhZFN0cmVhbSBhbmQgcGlwZSBkYXRhIHRvIHRoZSB3cml0ZSBzdHJlYW1cbiAgLy8gKGZvciBzb21lIG9kZCByZWFzb24gQi5wcm9taXNpZnkgZG9lc24ndCB3b3JrIG9uIHppcGZpbGUub3BlblJlYWRTdHJlYW0sIGl0IGNhdXNlcyBhbiBlcnJvciAnY2xvc2VkJylcbiAgY29uc3QgemlwUmVhZFN0cmVhbSA9IGF3YWl0IG5ldyBCKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB6aXBGaWxlLm9wZW5SZWFkU3RyZWFtKGVudHJ5LCAoZXJyLCByZWFkU3RyZWFtKSA9PiBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUocmVhZFN0cmVhbSkpO1xuICB9KTtcbiAgY29uc3QgemlwUmVhZFN0cmVhbVByb21pc2UgPSBuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgemlwUmVhZFN0cmVhbS5vbmNlKCdlbmQnLCByZXNvbHZlKTtcbiAgICB6aXBSZWFkU3RyZWFtLm9uY2UoJ2Vycm9yJywgcmVqZWN0KTtcbiAgfSk7XG4gIHppcFJlYWRTdHJlYW0ucGlwZSh3cml0ZVN0cmVhbSk7XG5cbiAgLy8gV2FpdCBmb3IgdGhlIHppcFJlYWRTdHJlYW0gYW5kIHdyaXRlU3RyZWFtIHRvIGVuZCBiZWZvcmUgcmV0dXJuaW5nXG4gIHJldHVybiBhd2FpdCBCLmFsbChbXG4gICAgemlwUmVhZFN0cmVhbVByb21pc2UsXG4gICAgd3JpdGVTdHJlYW1Qcm9taXNlLFxuICBdKTtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiBaaXBFbnRyeVxuICogQHByb3BlcnR5IHt5YXV6bC5FbnRyeX0gZW50cnkgVGhlIGFjdHVhbCBlbnRyeSBpbnN0YW5jZVxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gZXh0cmFjdEVudHJ5VG8gQW4gYXN5bmMgZnVuY3Rpb24sIHdoaWNoIGFjY2VwdHMgb25lIHBhcmFtZXRlci5cbiAqIFRoaXMgcGFyYW1ldGVyIGNvbnRhaW5zIHRoZSBkZXN0aW5hdGlvbiBmb2xkZXIgcGF0aCB0byB3aGljaCB0aGlzIGZ1bmN0aW9uIGlzIGdvaW5nIHRvIGV4dHJhY3QgdGhlIGVudHJ5LlxuICovXG5cbi8qKlxuICogR2V0IGVudHJpZXMgZm9yIGEgemlwIGZvbGRlclxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB6aXBGaWxlUGF0aCBUaGUgZnVsbCBwYXRoIHRvIHRoZSBzb3VyY2UgWklQIGZpbGVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uRW50cnkgQ2FsbGJhY2sgd2hlbiBlbnRyeSBpcyByZWFkLlxuICogVGhlIGNhbGxiYWNrIGlzIGV4cGVjdGVkIHRvIGFjY2VwdCBvbmUgYXJndW1lbnQgb2YgWmlwRW50cnkgdHlwZS5cbiAqIFRoZSBpdGVyYXRpb24gdGhyb3VnaCB0aGUgc291cmNlIHppcCBmaWxlIHdpbGwgYmkgdGVybWluYXRlZCBhcyBzb29uIGFzXG4gKiB0aGUgcmVzdWx0IG9mIHRoaXMgZnVuY3Rpb24gZXF1YWxzIHRvIGBmYWxzZWAuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlYWRFbnRyaWVzICh6aXBGaWxlUGF0aCwgb25FbnRyeSkge1xuICAvLyBPcGVuIGEgemlwIGZpbGUgYW5kIHN0YXJ0IHJlYWRpbmcgZW50cmllc1xuICBjb25zdCB6aXBmaWxlID0gYXdhaXQgb3BlblppcCh6aXBGaWxlUGF0aCwge2xhenlFbnRyaWVzOiB0cnVlfSk7XG4gIGNvbnN0IHppcFJlYWRTdHJlYW1Qcm9taXNlID0gbmV3IEIoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHppcGZpbGUub25jZSgnZW5kJywgcmVzb2x2ZSk7XG4gICAgemlwZmlsZS5vbmNlKCdlcnJvcicsIHJlamVjdCk7XG5cbiAgICAvLyBPbiBlYWNoIGVudHJ5LCBjYWxsICdvbkVudHJ5JyBhbmQgdGhlbiByZWFkIHRoZSBuZXh0IGVudHJ5XG4gICAgemlwZmlsZS5vbignZW50cnknLCBhc3luYyAoZW50cnkpID0+IHtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IG9uRW50cnkoe1xuICAgICAgICBlbnRyeSxcbiAgICAgICAgZXh0cmFjdEVudHJ5VG86IGFzeW5jIChkZXN0RGlyKSA9PiBhd2FpdCBfZXh0cmFjdEVudHJ5VG8oemlwZmlsZSwgZW50cnksIGRlc3REaXIpXG4gICAgICB9KTtcbiAgICAgIGlmIChyZXMgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB6aXBmaWxlLmVtaXQoJ2VuZCcpO1xuICAgICAgfVxuICAgICAgemlwZmlsZS5yZWFkRW50cnkoKTtcbiAgICB9KTtcbiAgfSk7XG4gIHppcGZpbGUucmVhZEVudHJ5KCk7XG5cbiAgLy8gV2FpdCBmb3IgdGhlIGVudHJpZXMgdG8gZmluaXNoIGJlaW5nIGl0ZXJhdGVkIHRocm91Z2hcbiAgcmV0dXJuIGF3YWl0IHppcFJlYWRTdHJlYW1Qcm9taXNlO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIFppcE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZW5jb2RlVG9CYXNlNjQgW2ZhbHNlXSBXaGV0aGVyIHRvIGVuY29kZVxuICogdGhlIHJlc3VsdGluZyBhcmNoaXZlIHRvIGEgYmFzZTY0LWVuY29kZWQgc3RyaW5nXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzTWV0ZXJlZCBbdHJ1ZV0gV2hldGhlciB0byBsb2cgdGhlIGFjdHVhbFxuICogYXJjaGl2ZXIgcGVyZm9ybWFuY2VcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhTaXplIFsxMDczNzQxODI0XSBUaGUgbWF4aW11bSBzaXplIG9mXG4gKiB0aGUgcmVzdWx0aW5nIGFyY2hpdmUgaW4gYnl0ZXMuIFRoaXMgaXMgc2V0IHRvIDFHQiBieSBkZWZhdWx0LCBiZWNhdXNlXG4gKiBBcHBpdW0gbGltaXRzIHRoZSBtYXhpbXVtIEhUVFAgYm9keSBzaXplIHRvIDFHQi4gQWxzbywgdGhlIE5vZGVKUyBoZWFwXG4gKiBzaXplIG11c3QgYmUgZW5vdWdoIHRvIGtlZXAgdGhlIHJlc3VsdGluZyBvYmplY3QgKHVzdWFsbHkgdGhpcyBzaXplIGlzXG4gKiBsaW1pdGVkIHRvIDEuNCBHQilcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsZXZlbCBbOV0gVGhlIGNvbXByZXNzaW9uIGxldmVsLiBUaGUgbWF4aW11bVxuICogbGV2ZWwgaXMgOSAodGhlIGJlc3QgY29tcHJlc3Npb24sIHdvcnN0IHBlcmZvcm1hbmNlKS4gVGhlIG1pbmltdW1cbiAqIGNvbXByZXNzaW9uIGxldmVsIGlzIDAgKG5vIGNvbXByZXNzaW9uKS5cbiAqL1xuXG4vKipcbiAqIENvbnZlcnRzIGNvbnRlbnRzIG9mIGxvY2FsIGRpcmVjdG9yeSB0byBhbiBpbi1tZW1vcnkgLnppcCBidWZmZXJcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3JjUGF0aCBUaGUgZnVsbCBwYXRoIHRvIHRoZSBmb2xkZXIgb3IgZmlsZSBiZWluZyB6aXBwZWRcbiAqIEBwYXJhbSB7WmlwT3B0aW9uc30gb3B0cyBaaXBwaW5nIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtQcm9taXNlPEJ1ZmZlcj59IFppcHBlZCAoYW5kIGVuY29kZWQgaWYgYGVuY29kZVRvQmFzZTY0YCBpcyB0cnV0aHkpXG4gKiBjb250ZW50IG9mIHRoZSBzb3VyY2UgcGF0aCBhcyBtZW1vcnkgYnVmZmVyXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIHJlYWRpbmcgdGhlIHNvdXJjZVxuICogb3IgdGhlIHNvdXJjZSBpcyB0b28gYmlnXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHRvSW5NZW1vcnlaaXAgKHNyY1BhdGgsIG9wdHMgPSAvKiogQHR5cGUge1ppcE9wdGlvbnN9ICovKHt9KSkge1xuICBpZiAoIWF3YWl0IGZzLmV4aXN0cyhzcmNQYXRoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTm8gc3VjaCBmaWxlIG9yIGZvbGRlcjogJHtzcmNQYXRofWApO1xuICB9XG5cbiAgY29uc3Qge1xuICAgIGlzTWV0ZXJlZCA9IHRydWUsXG4gICAgZW5jb2RlVG9CYXNlNjQgPSBmYWxzZSxcbiAgICBtYXhTaXplID0gMSAqIEdpQixcbiAgICBsZXZlbCA9IDksXG4gIH0gPSBvcHRzO1xuICBjb25zdCByZXN1bHRCdWZmZXJzID0gW107XG4gIGxldCByZXN1bHRCdWZmZXJzU2l6ZSA9IDA7XG4gIC8vIENyZWF0ZSBhIHdyaXRhYmxlIHN0cmVhbSB0aGF0IHppcCBidWZmZXJzIHdpbGwgYmUgc3RyZWFtZWQgdG9cbiAgY29uc3QgcmVzdWx0V3JpdGVTdHJlYW0gPSBuZXcgc3RyZWFtLldyaXRhYmxlKHtcbiAgICB3cml0ZTogKGJ1ZmZlciwgZW5jb2RpbmcsIG5leHQpID0+IHtcbiAgICAgIHJlc3VsdEJ1ZmZlcnMucHVzaChidWZmZXIpO1xuICAgICAgcmVzdWx0QnVmZmVyc1NpemUgKz0gYnVmZmVyLmxlbmd0aDtcbiAgICAgIGlmIChtYXhTaXplID4gMCAmJiByZXN1bHRCdWZmZXJzU2l6ZSA+IG1heFNpemUpIHtcbiAgICAgICAgcmVzdWx0V3JpdGVTdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoYFRoZSBzaXplIG9mIHRoZSByZXN1bHRpbmcgYCArXG4gICAgICAgICAgYGFyY2hpdmUgbXVzdCBub3QgYmUgZ3JlYXRlciB0aGFuICR7dG9SZWFkYWJsZVNpemVTdHJpbmcobWF4U2l6ZSl9YCkpO1xuICAgICAgfVxuICAgICAgbmV4dCgpO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8vIFppcCAnc3JjRGlyJyBhbmQgc3RyZWFtIGl0IHRvIHRoZSBhYm92ZSB3cml0YWJsZSBzdHJlYW1cbiAgY29uc3QgYXJjaGl2ZSA9IGFyY2hpdmVyKCd6aXAnLCB7XG4gICAgemxpYjoge2xldmVsfVxuICB9KTtcbiAgbGV0IHNyY1NpemUgPSBudWxsO1xuICBjb25zdCBiYXNlNjRFbmNvZGVyU3RyZWFtID0gZW5jb2RlVG9CYXNlNjQgPyBuZXcgQmFzZTY0RW5jb2RlKCkgOiBudWxsO1xuICBjb25zdCByZXN1bHRXcml0ZVN0cmVhbVByb21pc2UgPSBuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgcmVzdWx0V3JpdGVTdHJlYW0ub25jZSgnZXJyb3InLCAoZSkgPT4ge1xuICAgICAgaWYgKGJhc2U2NEVuY29kZXJTdHJlYW0pIHtcbiAgICAgICAgYXJjaGl2ZS51bnBpcGUoYmFzZTY0RW5jb2RlclN0cmVhbSk7XG4gICAgICAgIGJhc2U2NEVuY29kZXJTdHJlYW0udW5waXBlKHJlc3VsdFdyaXRlU3RyZWFtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFyY2hpdmUudW5waXBlKHJlc3VsdFdyaXRlU3RyZWFtKTtcbiAgICAgIH1cbiAgICAgIGFyY2hpdmUuYWJvcnQoKTtcbiAgICAgIGFyY2hpdmUuZGVzdHJveSgpO1xuICAgICAgcmVqZWN0KGUpO1xuICAgIH0pO1xuICAgIHJlc3VsdFdyaXRlU3RyZWFtLm9uY2UoJ2ZpbmlzaCcsICgpID0+IHtcbiAgICAgIHNyY1NpemUgPSBhcmNoaXZlLnBvaW50ZXIoKTtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9KTtcbiAgfSk7XG4gIGNvbnN0IGFyY2hpdmVTdHJlYW1Qcm9taXNlID0gbmV3IEIoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGFyY2hpdmUub25jZSgnZmluaXNoJywgcmVzb2x2ZSk7XG4gICAgYXJjaGl2ZS5vbmNlKCdlcnJvcicsIChlKSA9PiByZWplY3QoXG4gICAgICBuZXcgRXJyb3IoYEZhaWxlZCB0byBhcmNoaXZlICcke3NyY1BhdGh9JzogJHtlLm1lc3NhZ2V9YCkpKTtcbiAgfSk7XG4gIGNvbnN0IHRpbWVyID0gaXNNZXRlcmVkID8gbmV3IFRpbWVyKCkuc3RhcnQoKSA6IG51bGw7XG4gIGlmICgoYXdhaXQgZnMuc3RhdChzcmNQYXRoKSkuaXNEaXJlY3RvcnkoKSkge1xuICAgIGFyY2hpdmUuZGlyZWN0b3J5KHNyY1BhdGgsIGZhbHNlKTtcbiAgfSBlbHNlIHtcbiAgICBhcmNoaXZlLmZpbGUoc3JjUGF0aCwge1xuICAgICAgbmFtZTogcGF0aC5iYXNlbmFtZShzcmNQYXRoKSxcbiAgICB9KTtcbiAgfVxuICBpZiAoYmFzZTY0RW5jb2RlclN0cmVhbSkge1xuICAgIGFyY2hpdmUucGlwZShiYXNlNjRFbmNvZGVyU3RyZWFtKTtcbiAgICBiYXNlNjRFbmNvZGVyU3RyZWFtLnBpcGUocmVzdWx0V3JpdGVTdHJlYW0pO1xuICB9IGVsc2Uge1xuICAgIGFyY2hpdmUucGlwZShyZXN1bHRXcml0ZVN0cmVhbSk7XG4gIH1cbiAgYXJjaGl2ZS5maW5hbGl6ZSgpO1xuXG4gIC8vIFdhaXQgZm9yIHRoZSBzdHJlYW1zIHRvIGZpbmlzaFxuICBhd2FpdCBCLmFsbChbYXJjaGl2ZVN0cmVhbVByb21pc2UsIHJlc3VsdFdyaXRlU3RyZWFtUHJvbWlzZV0pO1xuXG4gIGlmICh0aW1lcikge1xuICAgIGxvZy5kZWJ1ZyhgWmlwcGVkICR7ZW5jb2RlVG9CYXNlNjQgPyAnYW5kIGJhc2U2NC1lbmNvZGVkICcgOiAnJ31gICtcbiAgICAgIGAnJHtwYXRoLmJhc2VuYW1lKHNyY1BhdGgpfScgYCArXG4gICAgICAoc3JjU2l6ZSA/IGAoJHt0b1JlYWRhYmxlU2l6ZVN0cmluZyhzcmNTaXplKX0pIGAgOiAnJykgK1xuICAgICAgYGluICR7dGltZXIuZ2V0RHVyYXRpb24oKS5hc1NlY29uZHMudG9GaXhlZCgzKX1zIGAgK1xuICAgICAgYChjb21wcmVzc2lvbiBsZXZlbDogJHtsZXZlbH0pYCk7XG4gIH1cbiAgLy8gUmV0dXJuIHRoZSBhcnJheSBvZiB6aXAgYnVmZmVycyBjb25jYXRlbmF0ZWQgaW50byBvbmUgYnVmZmVyXG4gIHJldHVybiBCdWZmZXIuY29uY2F0KHJlc3VsdEJ1ZmZlcnMpO1xufVxuXG4vKipcbiAqIFZlcmlmaWVzIHdoZXRoZXIgdGhlIGdpdmVuIGZpbGUgaXMgYSB2YWxpZCBaSVAgYXJjaGl2ZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlUGF0aCAtIEZ1bGwgcGF0aCB0byB0aGUgZmlsZVxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBmaWxlIGRvZXMgbm90IGV4aXN0IG9yIGlzIG5vdCBhIHZhbGlkIFpJUCBhcmNoaXZlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGFzc2VydFZhbGlkWmlwIChmaWxlUGF0aCkge1xuICBpZiAoIWF3YWl0IGZzLmV4aXN0cyhmaWxlUGF0aCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBmaWxlIGF0ICcke2ZpbGVQYXRofScgZG9lcyBub3QgZXhpc3RgKTtcbiAgfVxuXG4gIGNvbnN0IHtzaXplfSA9IGF3YWl0IGZzLnN0YXQoZmlsZVBhdGgpO1xuICBpZiAoc2l6ZSA8IDQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBmaWxlIGF0ICcke2ZpbGVQYXRofScgaXMgdG9vIHNtYWxsIHRvIGJlIGEgWklQIGFyY2hpdmVgKTtcbiAgfVxuICBjb25zdCBmZCA9IGF3YWl0IGZzLm9wZW4oZmlsZVBhdGgsICdyJyk7XG4gIHRyeSB7XG4gICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jKFpJUF9NQUdJQy5sZW5ndGgpO1xuICAgIGF3YWl0IGZzLnJlYWQoZmQsIGJ1ZmZlciwgMCwgWklQX01BR0lDLmxlbmd0aCwgMCk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYnVmZmVyLnRvU3RyaW5nKCdhc2NpaScpO1xuICAgIGlmIChzaWduYXR1cmUgIT09IFpJUF9NQUdJQykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZmlsZSBzaWduYXR1cmUgJyR7c2lnbmF0dXJlfScgb2YgJyR7ZmlsZVBhdGh9JyBgICtcbiAgICAgICAgYGlzIG5vdCBlcXVhbCB0byB0aGUgZXhwZWN0ZWQgWklQIGFyY2hpdmUgc2lnbmF0dXJlICcke1pJUF9NQUdJQ30nYCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9IGZpbmFsbHkge1xuICAgIGF3YWl0IGZzLmNsb3NlKGZkKTtcbiAgfVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIFppcENvbXByZXNzaW9uT3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGxldmVsIFs5XSAtIENvbXByZXNzaW9uIGxldmVsIGluIHJhbmdlIDAuLjlcbiAqIChncmVhdGVyIG51bWJlcnMgbWVhbiBiZXR0ZXIgY29tcHJlc3Npb24sIGJ1dCBsb25nZXIgcHJvY2Vzc2luZyB0aW1lKVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgWmlwU291cmNlT3B0aW9uc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IHBhdHRlcm4gWycqKlxcLyonXSAtIEdMT0IgcGF0dGVybiBmb3IgY29tcHJlc3Npb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjd2QgLSBUaGUgc291cmNlIHJvb3QgZm9sZGVyICh0aGUgcGFyZW50IGZvbGRlciBvZlxuICogdGhlIGRlc3RpbmF0aW9uIGZpbGUgYnkgZGVmYXVsdClcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IFtpZ25vcmVdIC0gVGhlIGxpc3Qgb2YgaWdub3JlZCBwYXR0ZXJuc1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcmNoaXZlIGJhc2VkIG9uIHRoZSBnaXZlbiBnbG9iIHBhdHRlcm5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZHN0UGF0aCAtIFRoZSByZXN1bHRpbmcgYXJjaGl2ZSBwYXRoXG4gKiBAcGFyYW0ge1ppcFNvdXJjZU9wdGlvbnN9IHNyYyAtIFNvdXJjZSBvcHRpb25zXG4gKiBAcGFyYW0ge1ppcENvbXByZXNzaW9uT3B0aW9uc30gb3B0cyAtIENvbXByZXNzaW9uIG9wdGlvbnNcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgY3JlYXRpbmcgdGhlIGFyY2hpdmVcbiAqL1xuYXN5bmMgZnVuY3Rpb24gdG9BcmNoaXZlIChkc3RQYXRoLCBzcmMgPSAvKiogQHR5cGUge1ppcFNvdXJjZU9wdGlvbnN9ICovKHt9KSwgb3B0cyA9IC8qKiBAdHlwZSB7WmlwQ29tcHJlc3Npb25PcHRpb25zfSAqLyh7fSkpIHtcbiAgY29uc3Qge1xuICAgIGxldmVsID0gOSxcbiAgfSA9IG9wdHM7XG4gIGNvbnN0IHtcbiAgICBwYXR0ZXJuID0gJyoqLyonLFxuICAgIGN3ZCA9IHBhdGguZGlybmFtZShkc3RQYXRoKSxcbiAgICBpZ25vcmUgPSBbXSxcbiAgfSA9IHNyYztcbiAgY29uc3QgYXJjaGl2ZSA9IGFyY2hpdmVyKCd6aXAnLCB7IHpsaWI6IHsgbGV2ZWwgfX0pO1xuICBjb25zdCBzdHJlYW0gPSBmcy5jcmVhdGVXcml0ZVN0cmVhbShkc3RQYXRoKTtcbiAgcmV0dXJuIGF3YWl0IG5ldyBCKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBhcmNoaXZlXG4gICAgICAuZ2xvYihwYXR0ZXJuLCB7XG4gICAgICAgIGN3ZCxcbiAgICAgICAgaWdub3JlLFxuICAgICAgfSlcbiAgICAgIC5vbignZXJyb3InLCByZWplY3QpXG4gICAgICAucGlwZShzdHJlYW0pO1xuICAgIHN0cmVhbVxuICAgICAgLm9uKCdlcnJvcicsIChlKSA9PiB7XG4gICAgICAgIGFyY2hpdmUudW5waXBlKHN0cmVhbSk7XG4gICAgICAgIGFyY2hpdmUuYWJvcnQoKTtcbiAgICAgICAgYXJjaGl2ZS5kZXN0cm95KCk7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH0pXG4gICAgICAub24oJ2ZpbmlzaCcsIHJlc29sdmUpO1xuICAgIGFyY2hpdmUuZmluYWxpemUoKTtcbiAgfSk7XG59XG5cbi8qKlxuICogRmluZHMgYW5kIG1lbW9pemVzIHRoZSBmdWxsIHBhdGggdG8gdGhlIGdpdmVuIGV4ZWN1dGFibGUuXG4gKiBSZWplY3RzIGlmIGl0IGlzIG5vdCBmb3VuZC5cbiAqL1xuY29uc3QgZ2V0RXhlY3V0YWJsZVBhdGggPSBfLm1lbW9pemUoXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBGdWxsIFBhdGggdG8gdGhlIGV4ZWN1dGFibGVcbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIGdldEV4ZWN1dGFibGVQYXRoIChiaW5hcnlOYW1lKSB7XG4gICAgY29uc3QgZnVsbFBhdGggPSBhd2FpdCBmcy53aGljaChiaW5hcnlOYW1lKTtcbiAgICBsb2cuZGVidWcoYEZvdW5kICclcycgYXQgJyVzJ2AsIGJpbmFyeU5hbWUsIGZ1bGxQYXRoKTtcbiAgICByZXR1cm4gZnVsbFBhdGg7XG4gIH1cbik7XG5cbmV4cG9ydCB7IGV4dHJhY3RBbGxUbywgcmVhZEVudHJpZXMsIHRvSW5NZW1vcnlaaXAsIF9leHRyYWN0RW50cnlUbyxcbiAgYXNzZXJ0VmFsaWRaaXAsIHRvQXJjaGl2ZSB9O1xuZXhwb3J0IGRlZmF1bHQgeyBleHRyYWN0QWxsVG8sIHJlYWRFbnRyaWVzLCB0b0luTWVtb3J5WmlwLCBhc3NlcnRWYWxpZFppcCwgdG9BcmNoaXZlIH07XG4iXX0=