"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MIME_PNG = exports.MIME_JPEG = exports.MIME_BMP = void 0;
exports.base64ToImage = base64ToImage;
exports.cropBase64Image = cropBase64Image;
exports.cropImage = cropImage;
exports.getJimpImage = getJimpImage;
exports.imageToBase64 = imageToBase64;

require("source-map-support/register");

var _lodash = _interopRequireDefault(require("lodash"));

var _jimp = _interopRequireDefault(require("jimp"));

var _buffer = require("buffer");

var _pngjs = require("pngjs");

var _bluebird = _interopRequireDefault(require("bluebird"));

const BYTES_IN_PIXEL_BLOCK = 4;
const SCANLINE_FILTER_METHOD = 4;
const {
  MIME_JPEG,
  MIME_PNG,
  MIME_BMP
} = _jimp.default;
exports.MIME_BMP = MIME_BMP;
exports.MIME_PNG = MIME_PNG;
exports.MIME_JPEG = MIME_JPEG;

async function getJimpImage(data) {
  return await new _bluebird.default((resolve, reject) => {
    if (!_lodash.default.isString(data) && !_lodash.default.isBuffer(data)) {
      return reject(new Error('Must initialize jimp object with string or buffer'));
    }

    if (_lodash.default.isString(data)) {
      data = _buffer.Buffer.from(data, 'base64');
    }

    new _jimp.default(data, (err, imgObj) => {
      if (err) {
        return reject(err);
      }

      if (!imgObj) {
        return reject(new Error('Could not create jimp image from that data'));
      }

      imgObj.getBuffer = _bluebird.default.promisify(imgObj.getBuffer.bind(imgObj), {
        context: imgObj
      });
      resolve(imgObj);
    });
  });
}

async function cropBase64Image(base64Image, rect) {
  const image = await base64ToImage(base64Image);
  cropImage(image, rect);
  return await imageToBase64(image);
}

async function base64ToImage(base64Image) {
  const imageBuffer = _buffer.Buffer.from(base64Image, 'base64');

  return await new _bluebird.default((resolve, reject) => {
    const image = new _pngjs.PNG({
      filterType: SCANLINE_FILTER_METHOD
    });
    image.parse(imageBuffer, (err, image) => {
      if (err) {
        return reject(err);
      }

      resolve(image);
    });
  });
}

async function imageToBase64(image) {
  return await new _bluebird.default((resolve, reject) => {
    const chunks = [];
    image.pack().on('data', chunk => chunks.push(chunk)).on('end', () => {
      resolve(_buffer.Buffer.concat(chunks).toString('base64'));
    }).on('error', err => {
      reject(err);
    });
  });
}

function cropImage(image, rect) {
  const imageRect = {
    width: image.width,
    height: image.height
  };
  const interRect = getRectIntersection(rect, imageRect);

  if (interRect.width < rect.width || interRect.height < rect.height) {
    throw new Error(`Cannot crop ${JSON.stringify(rect)} from ${JSON.stringify(imageRect)} because the intersection between them was not the size of the rect`);
  }

  const firstVerticalPixel = interRect.top;
  const lastVerticalPixel = interRect.top + interRect.height;
  const firstHorizontalPixel = interRect.left;
  const lastHorizontalPixel = interRect.left + interRect.width;
  const croppedArray = [];

  for (let y = firstVerticalPixel; y < lastVerticalPixel; y++) {
    for (let x = firstHorizontalPixel; x < lastHorizontalPixel; x++) {
      const firstByteIdxInPixelBlock = imageRect.width * y + x << 2;

      for (let byteIdx = 0; byteIdx < BYTES_IN_PIXEL_BLOCK; byteIdx++) {
        croppedArray.push(image.data[firstByteIdxInPixelBlock + byteIdx]);
      }
    }
  }

  image.data = _buffer.Buffer.from(croppedArray);
  image.width = interRect.width;
  image.height = interRect.height;
  return image;
}

function getRectIntersection(rect, imageSize) {
  const left = rect.left >= imageSize.width ? imageSize.width : rect.left;
  const top = rect.top >= imageSize.height ? imageSize.height : rect.top;
  const width = imageSize.width >= left + rect.width ? rect.width : imageSize.width - left;
  const height = imageSize.height >= top + rect.height ? rect.height : imageSize.height - top;
  return {
    left,
    top,
    width,
    height
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9pbWFnZS11dGlsLmpzIl0sIm5hbWVzIjpbIkJZVEVTX0lOX1BJWEVMX0JMT0NLIiwiU0NBTkxJTkVfRklMVEVSX01FVEhPRCIsIk1JTUVfSlBFRyIsIk1JTUVfUE5HIiwiTUlNRV9CTVAiLCJKaW1wIiwiZ2V0SmltcEltYWdlIiwiZGF0YSIsIkIiLCJyZXNvbHZlIiwicmVqZWN0IiwiXyIsImlzU3RyaW5nIiwiaXNCdWZmZXIiLCJFcnJvciIsIkJ1ZmZlciIsImZyb20iLCJlcnIiLCJpbWdPYmoiLCJnZXRCdWZmZXIiLCJwcm9taXNpZnkiLCJiaW5kIiwiY29udGV4dCIsImNyb3BCYXNlNjRJbWFnZSIsImJhc2U2NEltYWdlIiwicmVjdCIsImltYWdlIiwiYmFzZTY0VG9JbWFnZSIsImNyb3BJbWFnZSIsImltYWdlVG9CYXNlNjQiLCJpbWFnZUJ1ZmZlciIsIlBORyIsImZpbHRlclR5cGUiLCJwYXJzZSIsImNodW5rcyIsInBhY2siLCJvbiIsImNodW5rIiwicHVzaCIsImNvbmNhdCIsInRvU3RyaW5nIiwiaW1hZ2VSZWN0Iiwid2lkdGgiLCJoZWlnaHQiLCJpbnRlclJlY3QiLCJnZXRSZWN0SW50ZXJzZWN0aW9uIiwiSlNPTiIsInN0cmluZ2lmeSIsImZpcnN0VmVydGljYWxQaXhlbCIsInRvcCIsImxhc3RWZXJ0aWNhbFBpeGVsIiwiZmlyc3RIb3Jpem9udGFsUGl4ZWwiLCJsZWZ0IiwibGFzdEhvcml6b250YWxQaXhlbCIsImNyb3BwZWRBcnJheSIsInkiLCJ4IiwiZmlyc3RCeXRlSWR4SW5QaXhlbEJsb2NrIiwiYnl0ZUlkeCIsImltYWdlU2l6ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUVBLE1BQU1BLG9CQUFvQixHQUFHLENBQTdCO0FBQ0EsTUFBTUMsc0JBQXNCLEdBQUcsQ0FBL0I7QUFDQSxNQUFNO0FBQUVDLEVBQUFBLFNBQUY7QUFBYUMsRUFBQUEsUUFB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LEdBQXVEaUIsU0FBUyxDQUFDakIsS0FBVixHQUFrQlUsSUFBdkY7QUFDQSxRQUFNVCxNQUFNLEdBQUdnQixTQUFTLENBQUNoQixNQUFWLElBQXFCTSxHQUFHLEdBQUd4QixJQUFJLENBQUNrQixNQUFoQyxHQUEwQ2xCLElBQUksQ0FBQ2tCLE1BQS9DLEdBQXlEZ0IsU0FBUyxDQUFDaEIsTUFBVixHQUFtQk0sR0FBM0Y7QUFDQSxTQUFPO0FBQUNHLElBQUFBLElBQUQ7QUFBT0gsSUFBQUEsR0FBUDtBQUFZUCxJQUFBQSxLQUFaO0FBQW1CQyxJQUFBQTtBQUFuQixHQUFQO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IEppbXAgZnJvbSAnamltcCc7XG5pbXBvcnQgeyBCdWZmZXIgfSBmcm9tICdidWZmZXInO1xuaW1wb3J0IHsgUE5HIH0gZnJvbSAncG5nanMnO1xuaW1wb3J0IEIgZnJvbSAnYmx1ZWJpcmQnO1xuXG5jb25zdCBCWVRFU19JTl9QSVhFTF9CTE9DSyA9IDQ7XG5jb25zdCBTQ0FOTElORV9GSUxURVJfTUVUSE9EID0gNDtcbmNvbnN0IHsgTUlNRV9KUEVHLCBNSU1FX1BORywgTUlNRV9CTVAgfSA9IEppbXA7XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiB0byBnZXQgYSBKaW1wIGltYWdlIG9iamVjdCBmcm9tIGJ1ZmZlciBvciBiYXNlNjQgZGF0YS4gSmltcFxuICogaXMgYSBncmVhdCBsaWJyYXJ5IGhvd2V2ZXIgaXQgZG9lcyBJTyBpbiB0aGUgY29uc3RydWN0b3Igc28gaXQncyBub3RcbiAqIGNvbnZlbmllbnQgZm9yIG91ciBhc3luYy9hd2FpdCBtb2RlbC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcnxzdHJpbmd9IGRhdGEgLSBiaW5hcnkgaW1hZ2UgYnVmZmVyIG9yIGJhc2U2NC1lbmNvZGVkIGltYWdlXG4gKiBzdHJpbmdcbiAqIEByZXR1cm5zIHtQcm9taXNlPEFwcGl1bUppbXA+fSAtIHRoZSBqaW1wIGltYWdlIG9iamVjdFxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRKaW1wSW1hZ2UgKGRhdGEpIHtcbiAgcmV0dXJuIGF3YWl0IG5ldyBCKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBpZiAoIV8uaXNTdHJpbmcoZGF0YSkgJiYgIV8uaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdNdXN0IGluaXRpYWxpemUgamltcCBvYmplY3Qgd2l0aCBzdHJpbmcgb3IgYnVmZmVyJykpO1xuICAgIH1cbiAgICAvLyBpZiBkYXRhIGlzIGEgc3RyaW5nLCBhc3N1bWUgaXQgaXMgYSBiYXNlNjQtZW5jb2RlZCBpbWFnZVxuICAgIGlmIChfLmlzU3RyaW5nKGRhdGEpKSB7XG4gICAgICBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSwgJ2Jhc2U2NCcpO1xuICAgIH1cbiAgICBuZXcgSmltcChkYXRhLFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge0Vycm9yP30gZXJyXG4gICAgICAgKiBAcGFyYW0ge0FwcGl1bUppbXB9IGltZ09ialxuICAgICAgICovXG4gICAgKGVyciwgaW1nT2JqKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICAgIGlmICghaW1nT2JqKSB7XG4gICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdDb3VsZCBub3QgY3JlYXRlIGppbXAgaW1hZ2UgZnJvbSB0aGF0IGRhdGEnKSk7XG4gICAgICB9XG4gICAgICBpbWdPYmouZ2V0QnVmZmVyID0gQi5wcm9taXNpZnkoaW1nT2JqLmdldEJ1ZmZlci5iaW5kKGltZ09iaiksIHtjb250ZXh0OiBpbWdPYmp9KTtcbiAgICAgIHJlc29sdmUoaW1nT2JqKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ3JvcCB0aGUgaW1hZ2UgYnkgZ2l2ZW4gcmVjdGFuZ2xlICh1c2UgYmFzZTY0IHN0cmluZyBhcyBpbnB1dCBhbmQgb3V0cHV0KVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlNjRJbWFnZSBUaGUgc3RyaW5nIHdpdGggYmFzZTY0IGVuY29kZWQgaW1hZ2VcbiAqIEBwYXJhbSB7UmVnaW9ufSByZWN0IFRoZSBzZWxlY3RlZCByZWdpb24gb2YgaW1hZ2VcbiAqIEByZXR1cm4ge1Byb21pc2U8c3RyaW5nPn0gYmFzZTY0IGVuY29kZWQgc3RyaW5nIG9mIGNyb3BwZWQgaW1hZ2VcbiAqL1xuYXN5bmMgZnVuY3Rpb24gY3JvcEJhc2U2NEltYWdlIChiYXNlNjRJbWFnZSwgcmVjdCkge1xuICBjb25zdCBpbWFnZSA9IGF3YWl0IGJhc2U2NFRvSW1hZ2UoYmFzZTY0SW1hZ2UpO1xuICBjcm9wSW1hZ2UoaW1hZ2UsIHJlY3QpO1xuICByZXR1cm4gYXdhaXQgaW1hZ2VUb0Jhc2U2NChpbWFnZSk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgcG5nanMgaW1hZ2UgZnJvbSBnaXZlbiBiYXNlNjQgaW1hZ2VcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZTY0SW1hZ2UgVGhlIHN0cmluZyB3aXRoIGJhc2U2NCBlbmNvZGVkIGltYWdlXG4gKiBAcmV0dXJuIHtQcm9taXNlPFBORz59IFRoZSBpbWFnZSBvYmplY3RcbiAqL1xuYXN5bmMgZnVuY3Rpb24gYmFzZTY0VG9JbWFnZSAoYmFzZTY0SW1hZ2UpIHtcbiAgY29uc3QgaW1hZ2VCdWZmZXIgPSBCdWZmZXIuZnJvbShiYXNlNjRJbWFnZSwgJ2Jhc2U2NCcpO1xuICByZXR1cm4gYXdhaXQgbmV3IEIoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGltYWdlID0gbmV3IFBORyh7ZmlsdGVyVHlwZTogU0NBTkxJTkVfRklMVEVSX01FVEhPRH0pO1xuICAgIGltYWdlLnBhcnNlKGltYWdlQnVmZmVyLCAoZXJyLCBpbWFnZSkgPT4geyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByb21pc2UvcHJlZmVyLWF3YWl0LXRvLWNhbGxiYWNrc1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKGltYWdlKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYmFzZTY0IHN0cmluZyBmb3IgZ2l2ZW4gaW1hZ2Ugb2JqZWN0XG4gKlxuICogQHBhcmFtIHtQTkd9IGltYWdlIFRoZSBpbWFnZSBvYmplY3RcbiAqIEByZXR1cm4ge1Byb21pc2U8c3RyaW5nPn0gVGhlIHN0cmluZyB3aXRoIGJhc2U2NCBlbmNvZGVkIGltYWdlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGltYWdlVG9CYXNlNjQgKGltYWdlKSB7XG4gIHJldHVybiBhd2FpdCBuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgY2h1bmtzID0gW107XG4gICAgaW1hZ2UucGFjaygpXG4gICAgLm9uKCdkYXRhJywgKGNodW5rKSA9PiBjaHVua3MucHVzaChjaHVuaykpLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICByZXNvbHZlKEJ1ZmZlci5jb25jYXQoY2h1bmtzKS50b1N0cmluZygnYmFzZTY0JykpO1xuICAgIH0pXG4gICAgLm9uKCdlcnJvcicsIChlcnIpID0+IHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcm9taXNlL3ByZWZlci1hd2FpdC10by1jYWxsYmFja3NcbiAgICAgIHJlamVjdChlcnIpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDcm9wIHRoZSBpbWFnZSBieSBnaXZlbiByZWN0YW5nbGVcbiAqXG4gKiBAcGFyYW0ge1BOR30gaW1hZ2UgVGhlIGltYWdlIHRvIG11dGF0ZSBieSBjcm9wcGluZ1xuICogQHBhcmFtIHtSZWdpb259IHJlY3QgVGhlIHNlbGVjdGVkIHJlZ2lvbiBvZiBpbWFnZVxuICovXG5mdW5jdGlvbiBjcm9wSW1hZ2UgKGltYWdlLCByZWN0KSB7XG4gIGNvbnN0IGltYWdlUmVjdCA9IHt3aWR0aDogaW1hZ2Uud2lkdGgsIGhlaWdodDogaW1hZ2UuaGVpZ2h0fTtcbiAgY29uc3QgaW50ZXJSZWN0ID0gZ2V0UmVjdEludGVyc2VjdGlvbihyZWN0LCBpbWFnZVJlY3QpO1xuICBpZiAoaW50ZXJSZWN0LndpZHRoIDwgcmVjdC53aWR0aCB8fCBpbnRlclJlY3QuaGVpZ2h0IDwgcmVjdC5oZWlnaHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjcm9wICR7SlNPTi5zdHJpbmdpZnkocmVjdCl9IGZyb20gJHtKU09OLnN0cmluZ2lmeShpbWFnZVJlY3QpfSBiZWNhdXNlIHRoZSBpbnRlcnNlY3Rpb24gYmV0d2VlbiB0aGVtIHdhcyBub3QgdGhlIHNpemUgb2YgdGhlIHJlY3RgKTtcbiAgfVxuXG4gIGNvbnN0IGZpcnN0VmVydGljYWxQaXhlbCA9IGludGVyUmVjdC50b3A7XG4gIGNvbnN0IGxhc3RWZXJ0aWNhbFBpeGVsID0gaW50ZXJSZWN0LnRvcCArIGludGVyUmVjdC5oZWlnaHQ7XG5cbiAgY29uc3QgZmlyc3RIb3Jpem9udGFsUGl4ZWwgPSBpbnRlclJlY3QubGVmdDtcbiAgY29uc3QgbGFzdEhvcml6b250YWxQaXhlbCA9IGludGVyUmVjdC5sZWZ0ICsgaW50ZXJSZWN0LndpZHRoO1xuXG4gIGNvbnN0IGNyb3BwZWRBcnJheSA9IFtdO1xuICBmb3IgKGxldCB5ID0gZmlyc3RWZXJ0aWNhbFBpeGVsOyB5IDwgbGFzdFZlcnRpY2FsUGl4ZWw7IHkrKykge1xuICAgIGZvciAobGV0IHggPSBmaXJzdEhvcml6b250YWxQaXhlbDsgeCA8IGxhc3RIb3Jpem9udGFsUGl4ZWw7IHgrKykge1xuICAgICAgY29uc3QgZmlyc3RCeXRlSWR4SW5QaXhlbEJsb2NrID0gKGltYWdlUmVjdC53aWR0aCAqIHkgKyB4KSA8PCAyO1xuICAgICAgZm9yIChsZXQgYnl0ZUlkeCA9IDA7IGJ5dGVJZHggPCBCWVRFU19JTl9QSVhFTF9CTE9DSzsgYnl0ZUlkeCsrKSB7XG4gICAgICAgIGNyb3BwZWRBcnJheS5wdXNoKGltYWdlLmRhdGFbZmlyc3RCeXRlSWR4SW5QaXhlbEJsb2NrICsgYnl0ZUlkeF0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGltYWdlLmRhdGEgPSBCdWZmZXIuZnJvbShjcm9wcGVkQXJyYXkpO1xuICBpbWFnZS53aWR0aCA9IGludGVyUmVjdC53aWR0aDtcbiAgaW1hZ2UuaGVpZ2h0ID0gaW50ZXJSZWN0LmhlaWdodDtcbiAgcmV0dXJuIGltYWdlO1xufVxuXG5mdW5jdGlvbiBnZXRSZWN0SW50ZXJzZWN0aW9uIChyZWN0LCBpbWFnZVNpemUpIHtcbiAgY29uc3QgbGVmdCA9IHJlY3QubGVmdCA+PSBpbWFnZVNpemUud2lkdGggPyBpbWFnZVNpemUud2lkdGggOiByZWN0LmxlZnQ7XG4gIGNvbnN0IHRvcCA9IHJlY3QudG9wID49IGltYWdlU2l6ZS5oZWlnaHQgPyBpbWFnZVNpemUuaGVpZ2h0IDogcmVjdC50b3A7XG4gIGNvbnN0IHdpZHRoID0gaW1hZ2VTaXplLndpZHRoID49IChsZWZ0ICsgcmVjdC53aWR0aCkgPyByZWN0LndpZHRoIDogKGltYWdlU2l6ZS53aWR0aCAtIGxlZnQpO1xuICBjb25zdCBoZWlnaHQgPSBpbWFnZVNpemUuaGVpZ2h0ID49ICh0b3AgKyByZWN0LmhlaWdodCkgPyByZWN0LmhlaWdodCA6IChpbWFnZVNpemUuaGVpZ2h0IC0gdG9wKTtcbiAgcmV0dXJuIHtsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHR9O1xufVxuXG5leHBvcnQge1xuICBjcm9wQmFzZTY0SW1hZ2UsIGJhc2U2NFRvSW1hZ2UsIGltYWdlVG9CYXNlNjQsIGNyb3BJbWFnZSxcbiAgZ2V0SmltcEltYWdlLCBNSU1FX0pQRUcsIE1JTUVfUE5HLCBNSU1FX0JNUFxufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T21pdDxKaW1wLCdnZXRCdWZmZXInPiAmIHtnZXRCdWZmZXI6IEppbXBbJ2dldEJ1ZmZlckFzeW5jJ119fSBBcHBpdW1KaW1wXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiBSZWdpb25cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsZWZ0XG4gKiBAcHJvcGVydHkge251bWJlcn0gdG9wXG4gKiBAcHJvcGVydHkge251bWJlcn0gd2lkdGhcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoZWlnaHRcbiAqL1xuIl19